
//Reasons for selection of towerpro: weight of cam, weight of system, stalling torque of 1.8kg/cm, speed 
According to the towerPro sg 90 datasheet:  
    //Dutycycle ranges from 1ms to 2ms with 1.5ms as midpoint
    //With the PWM frequency as 50Hz, period = 20ms.
    //Therefore: 1ms/20ms = 5%
                1.5ms/20ms = 7.5%
                2ms/20ms = 10%

Dutycycle calculation equation: angle/18. + 3, 
where the bias term 3 is used to account for the fact that when the angle is zero the neutral point of the pan motor, 
the dutycycle should be 5% 

Change dutyCycle calculation bias to 8. 
    -90/18 + 8 = 3%
    0/18 + 8 = 8%
    90/18 + 8 = 13%
This is a closer approximation than a bias of 2 or 3.

This comes from the error calculation as:
    setPoint - actualValue = :
    framecenter - objectCenter

    This is negative when the person is to the left,    
    for which pid update output results to a value 0 to -90%, 
    for which the duty cycle calculation results range from 3% to 8%, panning the camera to the left,
    with further left locations of object giving larger errors close to abs(-90%), hence dutycycles closer to 3%, which is equivalent
    to 1ms for all way left according to the towerPro sg90 datasheet.

    This is positive when the person is to the right, 
    for which pid update output results to a value 0 to 90%, 
    for which the duty cycle calculation results range from 8% to 13%, panning the camera to the right,
    with further right locations of object giving larger errors close to 90%, hence dutycycles closer to 13%, which is equivalent
    to 2ms for all way right according to the towerPro sg90 datasheet.


Next steps:
    Now pid output values are set only if in range -90 to 90.
    Map pid output values. Evaluate if the simple solution suffices, the calculations of which are given above.
    Map servo input values after pid calculation in set_servo funtion(set_pan, set_tilt)
    Currently pid output is given as it is
    

   // Evaluating servoRanges to use and how this propagates back from pid output angles to pid input as error from object
    //location variation:
    Setting direction of pid reverse:
    (This wouldn't be the case if I used range 0-180, but then range -90 to 90 more accurately resembles/represents towerpro
    sg 90 motor dutycycle ranges as pid output well as ranges for error calcution framecenter - objectCenter as pid input.
    This inherent homegeneity of spread means less translatory functions (adapters) are required)
    Is there a need to set pid in reverse direction between ranges -90 to 0 
    so an increase in angle (less negative) means a decrease in the output angle given.
    This only means that kp = -kp, ki = -ki, , kd = -kd
    While in ranges 0 to 90:
    An increase in angle also means an increase in pid output and these are directly correlated so direction is forward.
    Notice that the above analysis is in reverse, with input as angle and output as pid output value, while these are the 
    same value in the current implementation, as no further mapping is required.

    Analysing further using a process/system approach, the input is the error framecenter - objectCenter, and pid takes this into 
    update function which runs throught the values as:
    stepping through a sample calculation then Plotting variations of these input  values framecenter, objectcenter, error, 
    prev_time, prev_error, deltatime, kp, ki, kd, pid output:
    //With the input as error and output as -90 to 90, and pid direction direction as forward throughout:
    //With pid as reverse between -90 to 0 and forward as 0 to 90:
    #out = pid_update(prev_time, prev_error, deltatime, kp, ki, kd, #pidoutput);
    for pan values: 
    Then plotting variations of output against error(negative to positive) for pan:


//Add flask web app
//Test manually to ensure main aim(respons) is attained 
//then add testing functions later to test more robustly: corroborate and document
//And provide good simulation values
//Additional: send data to flask web_app and code matplotlib graphs. Plotly?

   (Hint: with framecenter as consistently, 320, 240 if framesize is 640*480):
    error calculation:
        pan:                                                    pid output:
            320 - objectx {-ve, object is to the right}             error = -x, 
            or             {+ve, object is to the left}
                            {max = 320 - 640 = -320}

            //The assertions below can be corroborated both from printed output values
            //and from opencv and tflite documentation:
            case 1: centrally located object:
                assert error = 0
            case 2: min = 320 - 640 (far right) = -320
                assert far right = 640
                assert error = -320

            case 3: max = 320 - 0 (farleft)
                assert far left = 0
                assert error = 320
            pid output:
            //test_pid

                case 1: 
                case2:
                case3:
        tilt:
            240 - objecty {-ve, object is to the bottom}
                          {+ve, object is to the top}
            centrally located object:
                assert error = 0
                min = 240 - 480 (bottom)
                max = 240 - 0 (top)
    Output calculation:
    out = -pid_update(error) //(preverror, timeprev, deltatime, kp, ki, kd):
    */Sample run: illustrate the need (or lack of) for maintaining direction throughout or setting it as reverse
    */most likely in the negative cases above:

    //This comprises a system modelling of cases and optimization of kp, ki,kd values as well as 
    //pid direction, that is +ve or -ve kp values, and identification of the values that give optimal angle values(response)
    1. //This comprises just an excel-style tabulation on google sheets (if it can take these advanced formulas)
        //Add 3-column with direct kp and 3-column with reverse kp, ki, kd
        1.1//Plotting/eda of the above data
        //In the simple case, exhaustive search with matplotlib plotting for exhaustive inclusive value ranges is used and 
        //favourable output is identified using rules such as good slope between -ve to +ve 
        1.2//Displaying matplotlib plot graphs online
    2. //A gradient descent, backpropagation and error functions can be used to train a neural network 
        //with input as all variables, weights between them assigned and outputs as servo angles in the right ranges.
        Check both

    
    Debug to cv window:
        Detection time: {timeofDetection}
        Frame center:   {frame_cx} X {frame_cy} Y 
        Object Center:  {crosshair_x.value} X {crosshair_y.value} Y
        error:          {error_pan} X {error_tilt} Y 
        PID output:     {pan_output} X {tilt_output} Y 
        Position:       {pan_position} X {tilt_position} Y 

//Next tune pids
//add function to limit pid outputs
//Then map output to -90 to 90
